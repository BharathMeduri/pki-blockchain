
package main

import (
    "html/template"
    "time"
    "fmt"
    "io"
    "io/ioutil"
    "os"
    "log"
    "net/http"
    "strings"
    "strconv"
    "math/big"
    "math/rand"
    "hash/crc32"
    "crypto/rsa"
    "crypto/sha256"
    "encoding/gob"

    "github.com/gorilla/mux"

    "github.com/ethereum/go-ethereum/accounts/abi/bind/backends"
    "github.com/ethereum/go-ethereum/rpc"
    "github.com/ethereum/go-ethereum/common"
    "github.com/ethereum/go-ethereum/accounts/abi/bind"
)

var mTempl map[string]*template.Template
var session *LuxUni_KYCSession

const gCryptoModulHash = "0xc353c3c46aac1626486df3223c06a925add7e122";
const gContractHash = "0x7f45677a364a03ecdf13ab4f1ce4ace960e09089";
const gIPCpath = "/home/alex/_Work/Eth_AeroNet_t/geth.ipc";
const gPswd = "ira";
const key = `{"address":"7b41bc79ca4d9bc12fb65d1f5d7f39418c03bc77","crypto":{"cipher":"aes-128-ctr","ciphertext":"5c385f8b1153c8d09b7032e2a09d02134f0e1f109747d85641c417584d399c88","cipherparams":{"iv":"a2d5f0de312656f47a58045e6df19ef5"},"kdf":"scrypt","kdfparams":{"dklen":32,"n":262144,"p":1,"r":8,"salt":"be4f9268570504758907a0bc61ccbcdcfe7f2bf83f659c820e82186a0939c4a8"},"mac":"610e8b6b3d2d6ec9acdacb4202aa6f405033da13e83d51eab7765215a2ad51bd"},"id":"3a5e6f54-c16d-4d3e-84bf-9a5558598b15","version":3}`

const gPrivateKeyPath = "a_pr.key";
var gPrivateKey *rsa.PrivateKey;

type CRegData struct {
	NodeSender   common.Address
	DataHash     []byte
	FileName     string
	Description  string
	Encrypted    *big.Int
	CryptoModule common.Address
	LinkFile     string
	CreationDate *big.Int
	Active       bool
}

// alternative aproach to passing the params to template - http://stackoverflow.com/questions/23802008/how-do-you-pass-multiple-objects-to-go-template
// general Go template description https://gohugo.io/templates/go-templates/
type CKYCFormParam struct {
    RandomNum    int
    RandomStr    string
    Docs         []CDocPrez
}
type CDocPrez struct {
    Id           int
    Name         string
    Desc         string
    Link         string
    Decryption   string
    Hash         string
    CreationDate  time.Time
    CreationStr   string
}

func init() {
    if mTempl == nil {
        mTempl = make( map[string]*template.Template )
    }
    t, e := template.ParseFiles("/home/alex/DocsFS/Dropbox/WORK/RD/LuxBCh/KYC/kyc-form.html")
    if e != nil {
        fmt.Printf("IMPORTANT: Error in parsing of template %v, %v\n", "form", e.Error())
        mTempl = nil
    } else {
        mTempl["UploadFile"] = template.Must(t, e)
    }

    t, e = template.ParseFiles("/home/alex/DocsFS/Dropbox/WORK/RD/LuxBCh/KYC/hashres-form.html")
    if e != nil {
        fmt.Printf("IMPORTANT: Error in parsing of template %v, %v\n", "form", e.Error())
        mTempl = nil
    } else {
        mTempl["HashResult"] = template.Must(t, e)
    }
}


/*#
  # https://blog.saush.com/2015/03/18/html-forms-and-go/
*/
func kycForm(w http.ResponseWriter, r *http.Request) {

    var formParam CKYCFormParam;
    var hashResult string ="";
    var changeData bool = true;

    err := r.ParseMultipartForm(32 << 20)
    if err != nil {
        fmt.Printf("No change data: Parsing multipart form: %v\n", err.Error())
        changeData = false;
    }

    if (changeData == true) {

        dels := r.MultipartForm.Value["Deletion"]
        if len(dels) > 0 {
            fmt.Printf("Debug: I am in deletion block")
            //dels := r.MultipartForm.Value["Deletion"]
            //dels := r.Form["Deletion"]
            for _, del := range dels {
                fmt.Printf("del=%v\n", del);
                delid, err := strconv.Atoi(del);
                if err != nil {
                    log.Fatalf("Deletion conversion error: %v", err.Error())
                }

                _, nerr := session.DeleteRegDatum(big.NewInt(int64(delid)))
                if nerr != nil {
                    log.Fatalf("Deletion error: %v", nerr)
                }
            }
        }

        //get a ref to the parsed multipart form
        m := r.MultipartForm
        files := m.File["UplFiles"];

        for i, _ := range files {
            //for each fileheader, get a handle to the actual file
            file, err := files[i].Open()
            defer file.Close()
            if err != nil {
                fmt.Printf("Parsing form: %v\n", err.Error())
                return
            }

            //create destination file making sure the path is writeable.
            dstFName := "/tmp/tst" + "_" + files[i].Filename
            dst, err := os.Create(dstFName)
            defer dst.Close()
            if err != nil {
                fmt.Printf("Unable to open the file for writing: %v\n", err.Error())
                return
            } else {
                fmt.Printf("Created file: %v\n", dstFName)
            }

            //copy the uploaded file to the destination file
            _, err = io.Copy(dst, file); 
            if err != nil {
                fmt.Printf("Unable to copy: %v\n", err.Error())
                return
            }

            hasher := crc32.NewIEEE()
            //_, err = io.Copy(hasher, dst);
            dst4hash, err := ioutil.ReadFile(dstFName);
            if err != nil {
                fmt.Println("Error in open file for hash: %v\n", err.Error())
            }
            hasher.Write(dst4hash);
            hashSum := hasher.Sum32()
            fmt.Printf("Hash: %x\n", hashSum)

            var desc string = ""
            var isEncrypt int64;
            descArr := r.MultipartForm.Value["Desc"]
            if (len(descArr) > 0) {
                desc = descArr[0];
            }            
            encryptArr := r.MultipartForm.Value["Encryption"]
            if (len(encryptArr) > 0) {
                if encryptArr[0] != "" {
                    isEncrypt = 1;
                }
            }            
            fmt.Printf("DEBUG before newRegDatum: hash=%v, fname=%v, desc=%v, encrypt=%v\n", 
                    strconv.Itoa(int(hashSum)), files[i].Filename, desc, isEncrypt)

            _, err = session.NewRegDatum( []byte(strconv.Itoa(int(hashSum))), files[i].Filename, desc, "", 
                        big.NewInt(isEncrypt), common.HexToAddress(gCryptoModulHash))
            if err != nil {
               log.Fatalf("Failed to add a record to blockchain: %v. ", err)
               fmt.Fprintln(w, err)
            }
            hashResult = strconv.Itoa(i+1) + " files processed."
        }
        // UplFile is id in the input "file" component of the form
        // http://stackoverflow.com/questions/33771167/handle-file-uploading-with-go
        // file, handler, err := r.FormFile("UplFile")       
        //out, err := os.Create("/tmp/tst_"+handler.Filename);
        
        hashResult = "Hash info is successfully loaded to blockchain." + hashResult;
        /*
        tmpl := mTempl["HashResult"]
        terr := tmpl.Execute(w, hashResult)
        if terr != nil {
            http.Error(w, terr.Error(), http.StatusInternalServerError)
        }
        */

    } /// end of changeData condition

    randomBase := 1000000
    random := rand.New(rand.NewSource(time.Now().UnixNano()));
    formParam.RandomNum = random.Intn(9*randomBase) + randomBase
    formParam.RandomStr = strconv.Itoa(formParam.RandomNum)

    fmt.Println("Debug: passing in GET mode")

    numRD, err := session.NumRegData()
    if err != nil {
        log.Fatalf("Failed to retrieve a total number of data records: %v", err)
    }
    fmt.Println("Number of data records (including those deleted)", numRD)

    for i := int64(0); i < numRD.Int64(); i++ {
        bi := big.NewInt(i)
        regDatum, err := session.RegData(bi)
        if err != nil {
            log.Fatalf("Failed to get deleted data: %v", err)
        }

        delRegDatum, err := session.DeletedRegData( bi)
        if err != nil {
            log.Fatalf("Deletion retrieval error: %v", err)
        }

        if delRegDatum.DeletionDate.Int64() == 0 {
            crDate := time.Unix(regDatum.CreationDate.Int64(), 0);
            var desc string
            var decrypt string

            if ( regDatum.Encrypted.Int64() != 0 ) { 
                encryptRegDatum, err := session.EncryptRegData( bi)
                if err != nil {
                    log.Fatalf("Encryption mapping retrieval error: %v", err)
                }
                if encryptRegDatum.EncryptDate.Int64() != 0 {
                    desc = fmt.Sprintf("%v...", encryptRegDatum.Data[0:10]);
                    bDecrypt, err := Decrypt(encryptRegDatum.Data, gPrivateKey)
                    if err != nil {
                        decrypt = ""
                    } else {
                        decrypt = string(bDecrypt)
                    }
                }
            } else {
                desc = regDatum.Description;
            }
            formParam.Docs = append(formParam.Docs, CDocPrez{ int(i), regDatum.FileName, desc, ""/* link */, decrypt,
                   string(regDatum.DataHash), crDate, crDate.String()} )
            fmt.Printf("Data received: %v, %v \n", regDatum.Description, crDate.String()) 
         }
    }

    tmpl := mTempl["UploadFile"]
    terr := tmpl.Execute(w, formParam)
    if terr != nil {
            http.Error(w, terr.Error(), http.StatusInternalServerError)
    }
}


func main() {
    
    if mTempl == nil { return; }
    
    gPrivateKey = new(rsa.PrivateKey);
    err := LoadPrivateKey(gPrivateKeyPath, gPrivateKey)
    if err != nil {
        gPrivateKey = nil;
        log.Printf("Private key is not loaded, omitting : %v\n", gPrivateKeyPath)
    } else {
        log.Printf("Private key successfully loaded : %v\n", gPrivateKeyPath)
    }

    // Create an IPC based RPC connection to a remote node
    conn, err := rpc.NewIPCClient(gIPCpath)
    if err != nil {
        log.Fatalf("Failed to connect to the Ethereum client: %v", err)
    }

    // Instantiate the contract, the address is taken from eth at the moment of contract initiation
    kyc, err := NewLuxUni_KYC(common.HexToAddress(gContractHash), backends.NewRPCBackend(conn))
    if err != nil {
        log.Fatalf("Failed to instantiate a smart contract: %v", err)
    }

    // Logging into Ethereum as a user
    auth, err := bind.NewTransactor(strings.NewReader(key), gPswd)
    if err != nil {
        log.Fatalf("Failed to create authorized transactor: %v", err)
    }

    session = &LuxUni_KYCSession{
        Contract: kyc,
        CallOpts: bind.CallOpts{
            Pending: true,
        },
        TransactOpts: bind.TransactOpts{
            From:     auth.From,
            Signer:   auth.Signer,
            GasLimit: big.NewInt(2000000),
        },
    }
    session.TransactOpts = *auth;
    session.TransactOpts.GasLimit = big.NewInt(2000000)
    
    // http://stackoverflow.com/questions/15834278/serving-static-content-with-a-root-url-with-the-gorilla-toolkit
    // subrouter - http://stackoverflow.com/questions/18720526/how-does-pathprefix-work-in-gorilla-mux-library-for-go
    r := mux.NewRouter();
    r.HandleFunc("/kyc-test", kycForm);
    fs := http.FileServer(http.Dir("/home/alex/DocsFS/Dropbox/WORK/RD/LuxBCh/KYC/public"));
    spref := http.StripPrefix("/public/", fs);
    r.PathPrefix("/public/").Handler(spref);
    http.Handle("/", r);

    //https://gist.github.com/denji/12b3a568f092ab951456 - SSL info
    //https://golanglibs.com/top?q=webrtc - webrtc server side for golang

    //var server = &http.Server{
    //    Addr : ":8071",
    //    Handler : r,
    //}

    log.Println("Listening...")
    //http.ListenAndServeTLS()
    http.ListenAndServeTLS(":8071", "server.pem", "server.key", r)
}

func LoadPrivateKey( path string, ptrPrivateKey *rsa.PrivateKey ) (error) {
    privatekeyfile, err := os.Open( path )
    if err != nil {
        return err;
    }

    decoder := gob.NewDecoder(privatekeyfile)
    err = decoder.Decode(ptrPrivateKey)
    if err != nil {
        return err;
    }
    privatekeyfile.Close()
    return nil;
}

func Decrypt(msg []byte, privateKey *rsa.PrivateKey) ([]byte, error) {
    if privateKey == nil {
        err := GeneralError{"Private keys is not loaded"}
        return nil, err;
    }

    label := []byte("")  
    hash := sha256.New()

    return rsa.DecryptOAEP(hash, rand.Reader, privateKey, msg, label)
}

type GeneralError struct {
   errMsg string;
}
func (e GeneralError) Error() string {
    return e.errMsg
}



